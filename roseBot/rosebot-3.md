# 语音助手是这样子的（三）

上一节的末尾，我们引入了归一化表达的思想，这种思想就是要把用户输入的实例归一化为一种更泛的通用表达形式，这样的话我们就可以在OpenDial中只使用归一化的表达式进行配置。那么核心的问题就在于如何实现实例化的输入匹配到归一化的表达式，本节我们将介绍一种自然语言处理中常用的技术——模式匹配，并使用这种技术来实现NLU的功能。在详细展开模式匹配的原理之前，我们再次回顾一下我们想要实现的目标：<br/>
<font size=4>** `把实例`&nbsp;&nbsp;设定闹钟&nbsp;&nbsp;`转换为模板`&nbsp;&nbsp;【D:set】【D:clock】**</font>


## 应该用Trie树

既然我们已经把实例化输入向归一化模板的泛化过程定义为匹配的操作，那么我们将使用一种擅长于匹配的数据结构——Trie树。Trie树也称作前缀树，如下图所示，在一棵Trie树中，每个节点表示一个状态，其中根节点代表初始状态，叶子节点表示匹配成功；非叶子节点可以由两种状态，一种表示匹配成功（图中节点12），一种表示转移实现的状态。每一个分支（节点间的边）表示一种匹配条件，若成功匹配了当前节点的前驱节点（即字符串的前缀），则从当前状态进入该节点所对应的边所指向的下一状态。
<div align=center>
![Trie tree example](https://raw.githubusercontent.com/rouseway/blogs/master/roseBot/rosebot-4.jpg)
</div>
很显然，图中的Trie树把许许多多的单词以共享前缀的方式组织起来形成了一个词典，当待匹配的文本输入时就逐个字符地在这棵树上行走，每走到一个成功状态就匹配到一个单词，比如输入“at table"逐个字符地在Trie树上遍历，当行走到5号节点时为一个成功态，即成功匹配了单词“at”，待匹配的字符串可以从空格处再次开始了。

## 不只一棵树
明白了Trie树的匹配原理，其实我们不难想象把实例转换为模板只不过就是把模板的元字符（【】成分）组织成Trie树，让实例在Trie上逐个字符地匹配。可是问题来了，仅仅是模板的元字符是不可能让实例逐个字符地匹配的，因为实例是自然语言。可是，如果我们建立两棵Trie树是否就可以了呢？一棵用来存储模板，一棵用来存储槽位所对应的词典。
<div align=center>
![Pattern and Dict Trie trees](https://raw.githubusercontent.com/rouseway/blogs/master/roseBot/rosebot-5.jpg)
</div>
是的，按照上图的方式我们构建两棵Trie树，左边的这棵用来存储模板（模板树），右边的这棵用来存储词典（词典树），Trie的成功态节点附带上一个属性值，在词典树中属性值设置为槽位的标识；在模板树种属性值设置为模板的附加信息。当实例需要进行匹配的时候，我们按照如下的步骤展开：
<div align=center>
![Trie trees matching stepsi](https://raw.githubusercontent.com/rouseway/blogs/master/roseBot/rosebot-6.jpg)
</div>
显然，用图示的两棵树来匹配实例“设置闹钟”，实例会从模板树的根节点出发，先尝试匹配【D:Set】，由于这是一个槽位，所以需要进一步到词典树里去匹配，在词典树种以深度优先的遍历原则在4号节点处成功匹配了“设置”两个字返回，则回到模板树继续；模板树也一样按照深度优先的原则，接下来尝试匹配【D:Clock】，一样到词典树种匹配到“闹钟”后返回，到达模板树的成功态。这样，我们就实现了一开始所要达到的目标，把实例“设置闹钟”转换为了模板“【D:Set】【D:Clock】”。


## 新的OpenDial配置

