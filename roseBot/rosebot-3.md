# 语音助手是这样子的（三）

上一节的末尾，我们引入了归一化表达的思想，这种思想就是要把用户输入的实例归一化为一种更泛的通用表达形式，这样的话我们就可以在OpenDial中只使用归一化的表达式进行配置。那么核心的问题就在于如何实现实例化的输入匹配到归一化的表达式，本节我们将介绍一种自然语言处理中常用的技术——模式匹配，并使用这种技术来实现NLU的功能。在详细展开模式匹配的原理之前，我们再次回顾一下我们想要实现的目标：<br/>
把实例&nbsp;`设定闹钟`&nbsp;转换为模板&nbsp;`【D:set】【D:clock】`


## 应该用Trie树

既然我们已经把实例化输入向归一化模板的泛化过程定义为匹配的操作，那么我们将使用一种擅长于匹配的数据结构——Trie树。Trie树也称作前缀树，如下图所示，在一棵Trie树中，每个节点表示一个状态，其中根节点代表初始状态，叶子节点表示匹配成功；非叶子节点可以由两种状态，一种表示匹配成功（图中节点12），一种表示转移实现的状态。每一个分支（节点间的边）表示一种匹配条件，若成功匹配了当前节点的前驱节点（即字符串的前缀），则从当前状态进入该节点所对应的边所指向的下一状态。
<div align=center>
![Trie tree example](https://raw.githubusercontent.com/rouseway/blogs/master/roseBot/rosebot-4.jpg)
</div>
很显然，图中的Trie树把许许多多的单词以共享前缀的方式组织起来形成了一个词典，当待匹配的文本输入时就逐个字符地在这棵树上行走，每走到一个成功状态就匹配到一个单词，比如输入“at table"逐个字符地在Trie树上遍历，当行走到5号节点时为一个成功态，即成功匹配了单词“at”，待匹配的字符串可以从空格处再次开始了。

## 不只一棵树
明白了Trie树的匹配原理，其实我们不难想象把实例转换为模板只不过就是把模板的元字符（【】成分）组织成Trie树，让实例在Trie上逐个字符地匹配。可是问题来了，仅仅是模板的元字符是不可能让实例逐个字符地匹配的，因为实例是自然语言。可是，如果我们建立两棵Trie树是否就可以了呢？一棵用来存储模板，一棵用来存储槽位所对应的词典。

那么，如何将模板的匹配应用到Trie树结构上呢？同样的道理，我们把节点定义为状态，节点间的边是转移条件，此时的转移条件不再是图1中单纯的一个字母，而是模板中的元字符，那么模板文法中定义了多少种元字符，就会产生多少个分支（转移条件）如图2所示。

## 新的OpenDial配置

